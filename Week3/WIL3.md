# 3주차 과제 실행하기

## fork와 clone에 대해서 알아보기
 
fork는 원본 작업의 변화를 알 수 있고, 그 변화를 내 작업에 반영하는게 가능하다. 하지만 clone의 경우 원본 코드만 가져오는 행위이기 때문에 변화는 알 수 없고, 내 코드의 변화를 원본에 반영하지도 못한다. Forking은 GitHub 계정에서 수행되고 복제는 Git을 사용하여 수행된다. 리포지토리를 fork할 때 원본 리포지토리(업스트림 리포지토리)의 복사본을 생성하지만 리포지토리는 GitHub 계정에 남아 있다. 반면에 저장소를 clone하면 저장소가 Git의 도움으로 로컬 컴퓨터에 복사된다. 

포크된 저장소에 대한 변경 사항은 pull 요청을 통해 원래 저장소와 병합할 수 있다. Pull request는 저장소 소유자를 노크하고 “일부 변경을 수행했으니 원하는 경우 이 변경 내용을 리포지토리에 병합하십시오.”라고 말한다. 반면에 로컬 머신(복제된 저장소)에서 변경한 사항은 원본 리포지토리로 직접 푸시할 수 있다. 이를 위해 사용자는 저장소에 대한 쓰기 권한이 있어야 한다. 그렇지 않으면 불가능하다. 사용자에게 쓰기 액세스 권한이 없는 경우 분기된 요청을 통해서만 이동할 수 있다. 따라서 이 경우 복제된 리포지토리에서 변경된 사항이 먼저 포크된 리포지토리로 푸시된 다음 풀 요청이 생성된다. fork는 개념이고 clone는 프로세스이다. Forking은 저장소의 별도 사본을 포함하며 관련된 명령이 없다. clone는 ‘git clone’ 명령을 통해 이루어지며 모든 코드 파일을 로컬 머신으로 수신하는 프로세스이다.

1) 포크없이 Git Repo 복제
복제는 3단계 프로세스이다.

-1단계: 저장소 복제
사용자는 GitHub의 업스트림 저장소에서 시작한다. 사용자가 개념에 관심이 있고 기여하고 싶어서 저장소로 이동했기 때문이다. 이 프로세스는 저장소를 로컬 시스템에 복제할 때 복제에서 시작된다. 이제 시스템에 프로젝트 파일의 정확한 사본이있어 변경을 수행한다.

-2단계: 원하는 내용을 변경
복제 후 기여자는 자신의 기여를 저장소에 제공한다. 소스 파일을 편집하여 버그를 수정하거나 기능을 추가하거나 코드를 최적화하는 형태로 기여한다. 이 단계에서 기여자는 단일 커밋 또는 여러 커밋을 저장소에 적용할 수 있다. 그러나 결론은 모든 것이 로컬 시스템에서 발생한다는 것이다.

-3단계: 변경 사항 푸시
변경 사항 또는 커밋이 완료되면 수정 사항을 업스트림 저장소로 푸시할 수 있다.

2) 포킹 후 Git Repo 복제
리포지토리 포크는 5단계 프로세스이지만 3단계는 복제와 정확히 동일하다. 첫 번째 단계와 마지막 단계만 복제와 다르다.

-1단계: 리포지토리 포크
다시 사용자는 GitHub의 업스트림 리포지토리에서 시작하지만 이 프로세스는 리포지토리를 자신의 GitHub 계정으로 포크할 때 포크에서 시작된다.

-2단계: 저장소 복제
복제와 동일하다.

-3단계: 원하는대로 변경
복제와 동일하다.

-4단계: 변경 사항 푸시
복제와 동일하다.

-5단계: 원본 리포지토리로 변경 사항 보내기
이 프로세스를 Git에서 풀 요청이라고 한다. 이 단계에서 사용자는 변경 사항을 기본 중앙 저장소에 병합하라는 요청으로 저장소 소유자에게 변경 사항을 보낸다.

[clone 과 fork 에 대해서 참고한 사이트](https://dejavuhyo.github.io/posts/difference-between-git-clone-and-git-fork/)

위 과제를 진행하면서 스터디 중에 진행되었던 clone과 fork의 차이에 대해서 잘 알 수 있었다. 다만 실습과정에서 git clone을 진행하고 본인 컴퓨터 내에서 진행을 해서 push를 한 후 pull request를 진행했어야 했는데 그냥 fork만 하고 진행을 해버렸다. clone에 대해서 좀 더 공부 해봐야 되겠다는 생각이 들었다.. 공부 할 것이 많다. <br>
추가적으로 git commit 컨벤션에 대해서 알아보자. 사실 이거 지켜서 pull request 했어야 했는데 git commit 컨벤션이 뭔지도 모르고 그냥 내버렸다 그래서 이것에 대해서 설명하려고 한다.

### 메시지 구조
먼저 커밋 메시지는 크게 제목, 본문, 꼬리말 세 가지 파트로 나누고, 각 파트는 빈줄을 두어서 구분합니다.<br>

type(옵션): [#issueNumber - ]Subject  // -> 제목
(한 줄을 띄워 분리합니다.)<br>
body(옵션) //  -> 본문 
(한 줄을 띄워 분리합니다.)<br>
footer(옵션) // -> 꼬리말 <br>
 
type : 어떤 의도로 커밋했는지를 type에 명시합니다. 자세한 사항은 아래서 설명하겠습니다.<br>
subject : 최대 50글자가 넘지 않도록 하고 마침표는 찍지 않습니다. 영문으로 표기하는 경우 동사(원형)를 가장 앞에 두고 첫 글자는 대문자로 표기합니다. <br>
body : 긴 설명이 필요한 경우에 작성합니다. 어떻게 했는지가 아니라, 무엇을 왜 했는지를 작성합니다. 최대 75자를 넘기지 않도록 합니다. <br>
footer : issue tracker ID를 명시하고 싶은 경우에 작성합니다. <br>

### 제목은 어떻게 작성하는가 
 
타입은 태그와 제목으로 구성되고, 태그는 영어로 쓰되 첫 문자는 대문자로 한다. 이번에 쓰는 태그로는 Feat 과 DOCS 태그가 있는데 각각 "새로운 기능을 추가할 경우", "문서를 수정한 경우" 에 사용하는 태그이다. 
### 제목은 어떻게 적는가?
 
제목은 코드 변경 사항에 대한 짧은 요약을 나타냅니다. 제목은 다음의 규칙을 지킵니다.<br>

1. 제목의 처음은 동사 원형으로 시작합니다.<br>
2. 총 글자 수는 50자 이내로 작성합니다.<br>
3. 마지막에 특수문자는 삽입하지 않습니다. 예) 마침표(.), 느낌표(!), 물음표(?)<br>
4. 제목은 개조식 구문으로 작성합니다.  <br>
예시)
Feat: "추가 get data api 함수"<br>
기타 본문과 꼬리말을 작성하는 방법도 있는데 이것은 너무 길어지므로 생략하도록 한다. <br>
[git 커밋 컨벤션 참고 사이트](https://overcome-the-limits.tistory.com/entry/%ED%98%91%EC%97%85-%ED%98%91%EC%97%85%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-git-%EC%BB%A4%EB%B0%8B%EC%BB%A8%EB%B2%A4%EC%85%98-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0)
